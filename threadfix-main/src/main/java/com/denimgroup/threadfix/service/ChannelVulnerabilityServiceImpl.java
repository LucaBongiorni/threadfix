////////////////////////////////////////////////////////////////////////
//
//     Copyright (c) 2009-2013 Denim Group, Ltd.
//
//     The contents of this file are subject to the Mozilla Public License
//     Version 2.0 (the "License"); you may not use this file except in
//     compliance with the License. You may obtain a copy of the License at
//     http://www.mozilla.org/MPL/
//
//     Software distributed under the License is distributed on an "AS IS"
//     basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
//     License for the specific language governing rights and limitations
//     under the License.
//
//     The Original Code is ThreadFix.
//
//     The Initial Developer of the Original Code is Denim Group, Ltd.
//     Portions created by Denim Group, Ltd. are Copyright (C)
//     Denim Group, Ltd. All Rights Reserved.
//
//     Contributor(s): Denim Group, Ltd.
//
////////////////////////////////////////////////////////////////////////
package com.denimgroup.threadfix.service;

import java.io.BufferedReader;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.net.URISyntaxException;
import java.net.URL;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.Date;
import java.util.Enumeration;
import java.util.GregorianCalendar;
import java.util.List;
import java.util.Locale;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;

import org.apache.commons.io.IOUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import com.denimgroup.threadfix.data.dao.ChannelTypeDao;
import com.denimgroup.threadfix.data.dao.ChannelVulnerabilityDao;
import com.denimgroup.threadfix.data.dao.GenericVulnerabilityDao;
import com.denimgroup.threadfix.data.entities.ChannelType;
import com.denimgroup.threadfix.data.entities.ChannelVulnerability;
import com.denimgroup.threadfix.data.entities.DefaultConfiguration;
import com.denimgroup.threadfix.data.entities.GenericVulnerability;
import com.denimgroup.threadfix.data.entities.ScannerType;
import com.denimgroup.threadfix.data.entities.VulnerabilityMap;

@Service
@Transactional(readOnly = true)
public class ChannelVulnerabilityServiceImpl implements ChannelVulnerabilityService{
	
	private final SanitizedLogger log = new SanitizedLogger(ChannelVulnerabilityServiceImpl.class);
	private ChannelVulnerabilityDao channelVulnerabilityDao;
	private GenericVulnerabilityDao genericVulnerabilityDao;
	private ChannelTypeDao channelTypeDao;
	private DefaultConfigService defaultConfigService;
	
	private static final String
		CSV_SPLIT_CHARACTER = ",",
		DATE_PATTERN = "MM/dd/yyyy hh:mm:ss";
	
	@Autowired
	public ChannelVulnerabilityServiceImpl(ChannelVulnerabilityDao channelVulnerabilityDao,
			ChannelTypeDao channelTypeDao,
			GenericVulnerabilityDao genericVulnerabilityDao,
			DefaultConfigService defaultConfigService) {
		this.channelVulnerabilityDao = channelVulnerabilityDao;
		this.genericVulnerabilityDao = genericVulnerabilityDao;
		this.defaultConfigService = defaultConfigService;
		this.channelTypeDao = channelTypeDao;
	}
	
	@Override
	public List<ChannelVulnerability> loadSuggested(String prefix) {
		return channelVulnerabilityDao.retrieveSuggested(prefix);
	}

	@Override
	public boolean isValidManualName(String code) {
		return channelVulnerabilityDao.isValidManualName(code);
	}

	@Override
	public List<ChannelVulnerability> loadAllManual() {
		return channelVulnerabilityDao.retrieveAllManual();
	}
	
	@Override
	public ScanPluginCheckBean checkPluginJar() {
		DefaultConfiguration configuration = defaultConfigService.loadCurrentConfiguration();
		
		if (configuration != null && configuration.getLastScannerMappingsUpdate() != null) {
			
			Calendar databaseDate = configuration.getLastScannerMappingsUpdate();
			Calendar pluginDate = getPluginTimestamp();
			
			if (pluginDate != null && databaseDate != null && !pluginDate.after(databaseDate)) {
				return new ScanPluginCheckBean(false, databaseDate, pluginDate);
			} else {
				return new ScanPluginCheckBean(true, databaseDate, pluginDate);
			}
		} else  {
			return new ScanPluginCheckBean(true, null, null);
		}
	}
	
	private Calendar getPluginTimestamp() {
		Calendar returnDate = null;
		
		try (ZipFile zipFile = getScannerPluginZipFileOrNull()) {
			if (zipFile != null) {
				InputStream versionStream = searchCsvFile("version.txt", zipFile);
				
				String result = IOUtils.toString(versionStream);
				
				if (result != null && !result.trim().isEmpty()) {
					returnDate = getCalendarFromString(result.trim());
				}
			}
		} catch (IOException e) {
			log.info("IOException thrown while attempting to close zip file.", e);
		}
		
		return returnDate;
	}
	
	private Calendar getCalendarFromString(String dateString) {

		Date date = null;
		try {
			date = new SimpleDateFormat(DATE_PATTERN, Locale.US).parse(dateString);
		} catch (ParseException e) {
			log.warn("Parsing of date from '" + dateString + "' failed.", e);
		}

		if (date != null) {
			log.debug("Successfully parsed date: " + date + ".");
			Calendar scanTime = new GregorianCalendar();
			scanTime.setTime(date);
			return scanTime;
		}
		
		log.warn("There was an error parsing the date, check the format and regex.");
		return null;
	}
	
	/**
	 * Add/Update ChannelVulnerabilities and their VulnerabilityMaps from reading csv file.
	 * @return
	 * @throws IOException
	 * @throws URISyntaxException
	 */
	@Override
	public List<String[]> updateChannelVulnerabilities() throws IOException, URISyntaxException {
		
		List<String[]> resultList = new ArrayList<String[]>();
		
		try (ZipFile zipFile = getScannerPluginZipFileOrNull()) {
			if (zipFile != null) {
				for (ScannerType type: ScannerType.values()) {
					String[] result = updateSingleScanner(zipFile, type);
					if (result != null) {
						resultList.add(result);
					}
				}
			}
		}
		
		updateUpdatedDate();
		
		return resultList;
	}
	
	private void updateUpdatedDate() {
		DefaultConfiguration configuration = defaultConfigService.loadCurrentConfiguration();
		
		configuration.setLastScannerMappingsUpdate(getPluginTimestamp());
		
		defaultConfigService.saveConfiguration(configuration);
	}

	private String[] updateSingleScanner(ZipFile zipFile, ScannerType type) {

		String line = "";
		String[] returnValue = null;
		
		ChannelType channelType = channelTypeDao.retrieveByName(type.getFullName());
		if (channelType == null) {
			log.warn("Unable to find ChannelType for type name: " + type.getFullName());
			return null;
		}
		
		try (InputStream zis = searchCsvFile(type.getShortName() + ".csv", zipFile)){
			if (zis != null) {
				try (BufferedReader br = new BufferedReader(new InputStreamReader(zis, "UTF-8"))) {
					int numUpdated = 0;
					while ((line = br.readLine()) != null) {
						if (updateCsvLine(channelType, line)) {
							numUpdated ++;
						}
					}
					
					if (numUpdated > 0) {
						returnValue = new String[]{type.getFullName(), String.valueOf(numUpdated)};
					}
					log.info("Updated " + numUpdated + " Channel Vulnerabilities for Channel Type " + type.getFullName());
				}
			}
			
		} catch (IOException e) {
			log.error("Error when trying to read file from scanners.jar", e);
		}
		
		return returnValue;
	}
	
	private boolean updateCsvLine(ChannelType channelType, String line) {
		// use comma as separator
		String[] elements = line.split(CSV_SPLIT_CHARACTER);
		String cvName = elements[0];
		String cvCode = elements[1];
		String genericId = elements[2];
		ChannelVulnerability cv = channelVulnerabilityDao.retrieveByCode(channelType, cvCode);

		try {
			GenericVulnerability gv = genericVulnerabilityDao.retrieveById(Integer.valueOf(genericId));
			if (gv == null) {
				log.warn("Unable to find Generic Vulnerability for GenericId " + genericId);
				return false;
			}
			if (cv != null) {
				// Update
				boolean isDifferent = false;
				if (!cv.getName().equalsIgnoreCase(cvName)) {
					cv.setName(cvName);
					isDifferent = true;
				}
				if (cv.getGenericVulnerability() == null || cv.getGenericVulnerability().getId() != gv.getId()) {
					
					if (cv.getGenericVulnerability() != null) {
						for (VulnerabilityMap map: cv.getVulnerabilityMaps()) {
							map.setChannelVulnerability(null);
						}
					}
					
					VulnerabilityMap map = new VulnerabilityMap();
					map.setMappable(true);
					map.setChannelVulnerability(cv);
					map.setGenericVulnerability(gv);
					cv.setVulnerabilityMaps(Arrays.asList(map));
					isDifferent = true;
				}
				if (isDifferent) {
					channelVulnerabilityDao.saveOrUpdate(cv);
					return true;
				}
			} else {
				// Create new
				cv = new ChannelVulnerability();
				cv.setCode(cvCode);
				cv.setName(cvName);
				cv.setChannelType(channelType);

				VulnerabilityMap map = new VulnerabilityMap();
				map.setMappable(true);
				map.setChannelVulnerability(cv);
				map.setGenericVulnerability(gv);
				cv.setVulnerabilityMaps(Arrays.asList(map));
				channelVulnerabilityDao.saveOrUpdate(cv);
				return true;
			}
		} catch (NumberFormatException e) {
			log.warn("genericId " + genericId + " is not a number");
		}
		
		return false;
	}
	
	private ZipFile getScannerPluginZipFileOrNull() {
		
		ZipFile returnFile = null;
		
		try {
			URL jarUrl = ChannelVulnerabilityServiceImpl.class.getClassLoader().getResource("scanners.jar");
			if (jarUrl != null) {
				File file = new File(jarUrl.toURI());
				returnFile = new ZipFile(file.getAbsolutePath());
			}
		} catch (URISyntaxException e) {
			e.printStackTrace();
		} catch (IOException e) {
			e.printStackTrace();
		}
		
		return returnFile;
	}
	
	private InputStream searchCsvFile(String name, ZipFile zipFile) throws IOException {
		Enumeration<? extends ZipEntry> entries = zipFile.entries();
		while (entries.hasMoreElements()) {
			ZipEntry e = entries.nextElement();
			if (e.getName().endsWith(name)) {
				return zipFile.getInputStream(e);
			}
		}
		return null;
	}
}
