////////////////////////////////////////////////////////////////////////
//
//     Copyright (c) 2009-2013 Denim Group, Ltd.
//
//     The contents of this file are subject to the Mozilla Public License
//     Version 2.0 (the "License"); you may not use this file except in
//     compliance with the License. You may obtain a copy of the License at
//     http://www.mozilla.org/MPL/
//
//     Software distributed under the License is distributed on an "AS IS"
//     basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
//     License for the specific language governing rights and limitations
//     under the License.
//
//     The Original Code is ThreadFix.
//
//     The Initial Developer of the Original Code is Denim Group, Ltd.
//     Portions created by Denim Group, Ltd. are Copyright (C)
//     Denim Group, Ltd. All Rights Reserved.
//
//     Contributor(s): Denim Group, Ltd.
//
////////////////////////////////////////////////////////////////////////
package com.denimgroup.threadfix.service;

import java.io.BufferedReader;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.net.URISyntaxException;
import java.net.URL;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.Date;
import java.util.Enumeration;
import java.util.GregorianCalendar;
import java.util.List;
import java.util.Locale;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;

import com.denimgroup.threadfix.data.dao.*;
import com.denimgroup.threadfix.data.entities.*;
import org.apache.commons.io.IOUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
@Transactional(readOnly = true)
public class ChannelVulnerabilityServiceImpl implements ChannelVulnerabilityService{
	
	private final SanitizedLogger log = new SanitizedLogger(ChannelVulnerabilityServiceImpl.class);
	private ChannelVulnerabilityDao channelVulnerabilityDao;
	private GenericVulnerabilityDao genericVulnerabilityDao;
	private ChannelTypeDao channelTypeDao;
	private DefaultConfigService defaultConfigService;
    private ChannelSeverityDao channelSeverityDao;
    private GenericSeverityDao genericSeverityDao;
	
	private static final String
		CSV_SPLIT_CHARACTER = ",",
		DATE_PATTERN = "MM/dd/yyyy hh:mm:ss";
	
	@Autowired
	public ChannelVulnerabilityServiceImpl(ChannelVulnerabilityDao channelVulnerabilityDao,
			ChannelTypeDao channelTypeDao,
			GenericVulnerabilityDao genericVulnerabilityDao,
			DefaultConfigService defaultConfigService,
            ChannelSeverityDao channelSeverityDao,
            GenericSeverityDao genericSeverityDao) {
		this.channelVulnerabilityDao = channelVulnerabilityDao;
		this.genericVulnerabilityDao = genericVulnerabilityDao;
		this.defaultConfigService = defaultConfigService;
		this.channelTypeDao = channelTypeDao;
        this.channelSeverityDao = channelSeverityDao;
        this.genericSeverityDao = genericSeverityDao;
	}
	
	@Override
	public List<ChannelVulnerability> loadSuggested(String prefix) {
		return channelVulnerabilityDao.retrieveSuggested(prefix);
	}

	@Override
	public boolean isValidManualName(String code) {
		return channelVulnerabilityDao.isValidManualName(code);
	}

	@Override
	public List<ChannelVulnerability> loadAllManual() {
		return channelVulnerabilityDao.retrieveAllManual();
	}
	
	@Override
	public ScanPluginCheckBean checkPluginJar() {
		DefaultConfiguration configuration = defaultConfigService.loadCurrentConfiguration();
		
		if (configuration != null && configuration.getLastScannerMappingsUpdate() != null) {
			
			Calendar databaseDate = configuration.getLastScannerMappingsUpdate();
			Calendar pluginDate = getPluginTimestamp();
			
			if (pluginDate != null && databaseDate != null && !pluginDate.after(databaseDate)) {
				return new ScanPluginCheckBean(false, databaseDate, pluginDate);
			} else {
				return new ScanPluginCheckBean(true, databaseDate, pluginDate);
			}
		} else  {
			return new ScanPluginCheckBean(true, null, null);
		}
	}
	
	private Calendar getPluginTimestamp() {
		Calendar returnDate = null;
		
		try (ZipFile zipFile = getScannerPluginZipFileOrNull()) {
			if (zipFile != null) {
				InputStream versionStream = searchCsvFile("version.txt", zipFile);
				
				String result = IOUtils.toString(versionStream);
				
				if (result != null && !result.trim().isEmpty()) {
					returnDate = getCalendarFromString(result.trim());
				}
			}
		} catch (IOException e) {
			log.info("IOException thrown while attempting to close zip file.", e);
		}
		
		return returnDate;
	}
	
	private Calendar getCalendarFromString(String dateString) {

		Date date = null;
		try {
			date = new SimpleDateFormat(DATE_PATTERN, Locale.US).parse(dateString);
		} catch (ParseException e) {
			log.warn("Parsing of date from '" + dateString + "' failed.", e);
		}

		if (date != null) {
			log.debug("Successfully parsed date: " + date + ".");
			Calendar scanTime = new GregorianCalendar();
			scanTime.setTime(date);
			return scanTime;
		}
		
		log.warn("There was an error parsing the date, check the format and regex.");
		return null;
	}
	
	/**
	 * Add/Update ChannelVulnerabilities and their VulnerabilityMaps from reading csv file.
	 * @return
	 * @throws IOException
	 * @throws URISyntaxException
	 */
	@Override
	public List<String[]> updateChannelVulnerabilities() throws IOException, URISyntaxException {
		
		List<String[]> resultList = null;
		
		try (ZipFile zipFile = getScannerPluginZipFileOrNull()) {
            if (zipFile != null) {
                resultList = updateAllScanners(zipFile);
            }
        }
		
		updateUpdatedDate();
		
		return resultList;
	}
	
	private void updateUpdatedDate() {
		DefaultConfiguration configuration = defaultConfigService.loadCurrentConfiguration();
		
		configuration.setLastScannerMappingsUpdate(getPluginTimestamp());
		
		defaultConfigService.saveConfiguration(configuration);
	}

	private List<String[]> updateAllScanners(ZipFile zipFile) {

        List<String[]> returnValue = new ArrayList<>();
        Enumeration<? extends ZipEntry> entries = zipFile.entries();
        while (entries.hasMoreElements()) {
            ZipEntry e = entries.nextElement();
            if (e.getName().endsWith(".csv")) {
                try {
                    InputStream zis = zipFile.getInputStream(e);
                    if (zis != null) {
                        log.info("Start updating file " + e.getName());
                        String[] temp = updateScanner(zis);
                        if (temp != null)
                            returnValue.add(temp);
                    }
                } catch (IOException ex) {
                    log.error("Error when trying to read file from scanners.jar", ex);
                }
            }
        }
		return returnValue;
	}
	
    private String[] updateScanner(InputStream is) {
            try {
                if (is != null) {
                    try (BufferedReader br = new BufferedReader(new InputStreamReader(is, "UTF-8"))) {
                        String line = "";
                        boolean isInTypeInfo = false;
                        boolean isInTypeVulns = false;
                        boolean isInTypeSeverities = false;
                        int vulnsNo = 0;
                        int sevsNo = 0;
                        ChannelType channelType = null;
                        while ((line = br.readLine()) != null) {
                            if (line.startsWith("type.info")) {
                                isInTypeInfo = true;
                                isInTypeSeverities = false;
                                isInTypeVulns = false;
                            } else if (line.startsWith("type.vulnerabilities")) {
                                isInTypeInfo = false;
                                isInTypeSeverities = false;
                                isInTypeVulns = true;
                            } else if (line.startsWith("type.severities")) {
                                isInTypeInfo = false;
                                isInTypeSeverities = true;
                                isInTypeVulns = false;
                            } else {
                                if (isInTypeInfo) {
                                    channelType = updateChannelTypeInfo(line);
                                    if (channelType == null)
                                        log.warn("Was unable to update Channel Type info for " + line);
                                } else if (isInTypeVulns) {
                                    if (channelType != null) {
                                        if (!updateChannelVuln(channelType, line))
                                            log.warn("Was unable to add " + line);
                                        else vulnsNo++;
                                    }
                                } else if (isInTypeSeverities) {
                                    if (channelType != null) {
                                        if (!updateChannelSeverity(channelType, line))
                                            log.warn("Was unable to add " + line);
                                        else sevsNo++;
                                    }
                                }
                            }
                        }
                        if (channelType != null) {
                            log.info("Number of vulnerabilites added for " + channelType.getName() + ": " + vulnsNo);
                            log.info("Number of severities added for " + channelType.getName() + ": " + sevsNo);
                            return new String[]{channelType.getName(), String.valueOf(vulnsNo), String.valueOf(sevsNo)};
                        }
                    }
                }
            } catch (IOException e) {
                log.error("IOException thrown while attempting to search csv file.", e);
            }
        return null;
    }

    private boolean updateChannelVuln(ChannelType channelType, String line) {
        // use comma as separator
        String[] elements = line.split(CSV_SPLIT_CHARACTER);
        if (elements.length < 3)
            return false;

        String cvName = elements[0];
        String cvCode = elements[1];
        String genericId = elements[2];
        ChannelVulnerability cv = channelVulnerabilityDao.retrieveByCode(channelType, cvCode);

        try {
            GenericVulnerability gv = genericVulnerabilityDao.retrieveById(Integer.valueOf(genericId));
            if (gv == null) {
                log.warn("Unable to find Generic Vulnerability for GenericId " + genericId);
                return false;
            }
            if (cv != null) {
                // Update
                boolean isDifferent = false;
                if (!cv.getName().equalsIgnoreCase(cvName)) {
                    cv.setName(cvName);
                    isDifferent = true;
                }
                if (cv.getGenericVulnerability() == null || cv.getGenericVulnerability().getId() != gv.getId()) {

                    if (cv.getGenericVulnerability() != null) {
                        for (VulnerabilityMap map: cv.getVulnerabilityMaps()) {
                            map.setChannelVulnerability(null);
                        }
                    }

                    VulnerabilityMap map = new VulnerabilityMap();
                    map.setMappable(true);
                    map.setChannelVulnerability(cv);
                    map.setGenericVulnerability(gv);
                    cv.setVulnerabilityMaps(Arrays.asList(map));
                    isDifferent = true;
                }
                if (isDifferent) {
                    channelVulnerabilityDao.saveOrUpdate(cv);
                    return true;
                }
            } else {
                // Create new
                cv = new ChannelVulnerability();
                cv.setCode(cvCode);
                cv.setName(cvName);
                cv.setChannelType(channelType);

                VulnerabilityMap map = new VulnerabilityMap();
                map.setMappable(true);
                map.setChannelVulnerability(cv);
                map.setGenericVulnerability(gv);
                cv.setVulnerabilityMaps(Arrays.asList(map));
                channelVulnerabilityDao.saveOrUpdate(cv);
                return true;
            }
        } catch (NumberFormatException e) {
            log.warn("genericId " + genericId + " is not a number");
        }

        return false;
    }

    private boolean updateChannelSeverity(ChannelType channelType, String line) {
        // use comma as separator
        String[] elements = line.split(CSV_SPLIT_CHARACTER);
        if (elements.length < 4)
            return false;

        String csName = elements[0];
        String csCode = elements[1];
        String csNumericValue = elements[2];
        String genericSeverityId = elements[3];
        ChannelSeverity cs = channelSeverityDao.retrieveByCode(channelType,csCode);

        try {
            if (cs == null) {
                cs = new ChannelSeverity();
                cs.setCode(csCode);
            }
            cs.setName(csName);
            cs.setChannelType(channelType);
            cs.setNumericValue(Integer.valueOf(csNumericValue));
            GenericSeverity gs = genericSeverityDao.retrieveByIntValue(Integer.valueOf(genericSeverityId));
            if (gs == null) {
                log.warn("Unable to find Generic Severity for SeverityId " + genericSeverityId);
                return false;
            }
            SeverityMap map = new SeverityMap();
            map.setChannelSeverity(cs);
            map.setGenericSeverity(gs);
            cs.setSeverityMap(map);
            channelSeverityDao.saveOrUpdate(cs);
            return true;
        } catch (NumberFormatException e) {
            log.warn("Numberic Value  " + csNumericValue + " or " + genericSeverityId + " is not a number");
        }

        return false;
    }


    private ChannelType updateChannelTypeInfo(String line) {
        ChannelType channelType = null;
        // use comma as separator
        String[] elements = line.split(CSV_SPLIT_CHARACTER);
        if (elements.length < 1)
            return channelType;

        String name = elements[0];
        channelType = channelTypeDao.retrieveByName(name);
        if (channelType != null)
            return channelType;
        if (elements.length < 4)
            return channelType;
        log.info("Creating new Channel Type " + name);
        channelType = new ChannelType();
        channelType.setName(name);
        channelType.setUrl(elements[1]);
        channelType.setVersion(elements[2]);
        channelType.setExportInfo(elements[3]);
        channelTypeDao.saveOrUpdate(channelType);
        return channelType;
    }

	private ZipFile getScannerPluginZipFileOrNull() {
		
		ZipFile returnFile = null;
		
		try {
			URL jarUrl = ChannelVulnerabilityServiceImpl.class.getClassLoader().getResource("scanners.jar");
			if (jarUrl != null) {
				File file = new File(jarUrl.toURI());
				returnFile = new ZipFile(file.getAbsolutePath());
			}
		} catch (URISyntaxException e) {
			e.printStackTrace();
		} catch (IOException e) {
			e.printStackTrace();
		}
		
		return returnFile;
	}
	
	private InputStream searchCsvFile(String name, ZipFile zipFile) throws IOException {
		Enumeration<? extends ZipEntry> entries = zipFile.entries();
		while (entries.hasMoreElements()) {
			ZipEntry e = entries.nextElement();
			if (e.getName().endsWith(name)) {
				return zipFile.getInputStream(e);
			}
		}
		return null;
	}
}
